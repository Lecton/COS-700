Digraph matching algorithms such as the Similarity Flooding[1] algorithms, VF[5], VF2[2], Ullman, Schmidt and Druffel algorithm[5] and the Nauty[5] are used in Computer Science to evaluate graph isomorphism  and sub-graph isomorphism problems on related graphs[1].
The solutions offered by most of graph matching algorithms are efficient, but because the algorithms approach the solution differently and are developed for different motives that solve the same problem, their degree of efficiency and quality of the solution is different.
The Similarity Flooding algorithm (SF) is a graph matching that was proposed by Sergey Menlik, Hector Garcia-Molina and Erhard Rahm [1], this is one of the interesting algorithms that is evaluated in this paper.
The SF algorithm works on two graphs (schemas, catalogues, or other data structures) that are related to each by their attributes, and it produces a multi-mapping of the corresponding nodes from the original input graphs [3]. The algorithm also uses filters that are applied to the resultant mapping that is produced by the algorithm, the purpose of the filters is to evaluate and produce the best mapping from the original mapping that was produced. The final, best mapping result from the algorithm is then reviewed, and if necessary, the results are adjusted [1].
What makes this algorithm effective with regards to graph matching is that, the algorithm itself is very versatile[1] and extensible[3] in that it only requires a general network representation of the of the graphs in order to perform the graph matching computation.
Another interesting graph matching algorithm that is analysed and studied in this paper is the VF2 algorithm [2]. The VF2 algorithm is an improvement of its predecessor, namely the VF algorithm[6]. The VF2 algorithm uses a more superior data structure for optimizing the matching time then the VF algorithm that is reported in [6].
The VF2 algorithm was introduced by L.P.Cordella, P.Foggiaa, C.Sansone and M.Vento. The algorithm is suitable for graph matching and isomorphic determination on large graphs, because its memory efficiency is significantly better then algorithms of the same kind [2]. In the VF2 algorithm, the mapping procedure is described using Space State Representation (SSR) that is described in [7]. Each mapping process has a state s, and the state is associated with a partial mapping solution M(s). The M(s) contains only the a subset of the components of the mapping function M. A partial M(s) identifies two sub graphs, one from Graphs A and another from B, namely GraphA(s) and GraphB(s). They are obtained by selecting the nodes that are in M(s) and their branches from Graph A and B. 
The algorithm uses a feasibility function [2] that prunes the search tree constructed using the graphs. If the value returned by the function is true, it guarantees that state’ s', which is obtained from adding the partial mapping solution M(s) and mapping solution M to the state s is a partial isomorphism in s. Thus the final state is either an isomorphism between GraphA and GraphB, or sub graph isomorphism between GraphA and GraphB[2].
One of the most widely known graph matching algorithms is the Ullman's algorithm [8]. The Ullman algorithm detects isomorphism on graphs as well as in sub graphs of graphs [8]; the algorithm accomplishes this by employing a backtracking procedure with an effective look-ahead function to reduce the search space [8].
Though the algorithm may be old, it is still amongst the most exact graph matching algorithms[9].This is due to the fact that the algorithm's generality and its effectiveness with regards to graph matching[2], the algorithms is also among the fastest algorithms for the sub graph isomorphism problem.
The algorithm uses a model graph G, as a base of comparison. It takes in an input graph that is to be compared with the model graph denoted as G1. The adjacency matrix of the model graph is M, thus it is an nxn array. The adjacency matrix of the input graph is M1, thus it is an mxm array, and the permutation matrix of the two matrices in denoted as P. The algorithm's computation is based on the notion of finding all the sub graphs isomorphism’s by gradually setting the permutation matrix P, it does this by using backtracking recursively through the graphs and setting the associated elements indexes in P.
The algorithms that have been discussed perform syntactical (isomorphic) graph matching well and they do so very efficiently, but they do not perform semantic comparison well, if they do so at all. This paper aims to extend onto these algorithms to perform both the syntactical matches and the semantic matches were most popular graph matching algorithms are lacking.
