 \asection{VF2 Algorithm}
\label{VF2 Algorithm}

\subsection{Background}
 The VF2 algorithm was introduced by L.P.Cordella, P.Foggiaa, C.Sansone and M.Vento[11]. The algorithm is suitable for graph matching and isomorphic determination, including subgraph isomorphic determination on large graphs, this is attributed to the Data structures that the algorithm uses and the manner in which they are used[11], this feature is discussed later in the paper.

\subsection{Algorithm}
\subsubsection{Overview}
The algorithm performs the matching process by attempting to find a mapping M, of vertices in graph G{\tiny A} which correspond to vertices in graph G{\tiny B}. The mapping is then used to determine if the two graphs are completely syntactically similar(isomorphic), partially syntactically similar or have no structural similarities at all.
\subsubsection{Matching and Mapping definition}
A mapping M is defined as a set of pairs (n,m), where n is a vertice from G{\tiny A} and m a vertice from G{\tiny B}, thus n<=G{\tiny A} and m<=G{\tiny B}.
The isomorphism determining properties of the mapping are defined as follows, a mapping M < NA X NB is isomorphic iff M is a bijection, that preserves the branching structure of G{\tiny A} and G{\tiny B}, where NA is a set of vertices from G{\tiny A} and NB a set of vertices from G{\tiny B}.\newline\newline
The mapping M < NA X NB is subgraph isomorphic iff M is isomorphic to G{\tiny A} and a subgraph of G{\tiny B}.

\subsubsection{Mapping Procedure}
The mapping M comprises of state based partial solution morphisms M(s) for each state s.The process of finding the mapping M that is described above uses State Space Representations(SSR)[12].
The partial solution morphisms M(s) selects two subgraphs from G{\tiny A} and G{\tiny B}, namely G{\tiny A}(s) and G{\tiny B}(s) respectively. The subgraphs comprises of only vertices that are present in the partial solution M(s) for the state s as well asthe edges joining them together.\newline\newline

The algorithm starts with an initial state s0 that has no mapping between the two graphs, thus M(s0)= NULL. The algorithm then computes a set of candidate pairs P(s). Each candidate p in the set is checked against the feasibility function that is discussed in the following chapter, if p is successful then it is added to the state s. And
the successor s' is computed using a combination of the predecessor state and the candidate p, thus:
	\begin{equation}
		s' = s \cup p
	\end{equation} 
The process of generating successor states is a recursive procedure that makes use of the depth first traversal for graphs. When a path has been 
exhausted and a solution has not yet been found, the algorithm uses backtracking to explore the alternative paths[11,13].

\subsubsection{Definition of the set P(s) and of the feasibility function F(s, n, m)}
The VF2 algorithm generates the states with close consideration that only some of the states are consistant with the desired morphisms[12]. The algorithm avoids inconsistant states by making use of a set of rules in it's state generation procedure, thus ensuring that only consistant state are generated, these rules are refered to as feasibility rules.\newline\newline

 The algorithm uses a function called a feasibility function to test that an additon of a pair(n,m) to a state will be consistant. If the addtion of the pair passes all the feasibility rules, the algorithm will return a true value, if not, a false value indicating that the procedure results in an inconsistant successor  state s', and thus that state s' will not be explored by the algorithm.\newline\newline
 A further filter can be applied in the consistent states to rule out those states whose successor states will be inconsistant, this apporoach is employed by adding a additional rules called k-look-ahead rules[12]. They check to see if the current state s will have a consistant successor state after k steps, i.e. they check to see if the states from s to s(pow(k)) are consistant with the desired morphisms.

 \subsubsection{Condidate Pairs}
 The candidate pairs are obtained by considering the vertexs that are connect to G{\tiny A}(s) and G{\tiny B}(s), the sub-graphs of G{\tiny A} and G{\tiny B} in the state s. The vertexs are used to form the pairs (n,m) as defined above. In order explain how the pairs are formed, we must first introduce the following definitions:
Let T{\tiny A}in(s) be the set of vertexs that are not yet in the partial mapping M(s) and are the origin of the edges from graph G{\tiny A}
	T{\tiny B}in(s) be the set of vertexs that are not yet in the partial mapping M(s) and are the origin of the edges from graph G{\tiny B}
	T{\tiny A}out(s) be the set of vertexs that are not yet in the partial mapping M(s) and are the destination of the edges from graph G{\tiny A}
	T{\tiny B}out(s) be the set of vertexs that are not yet in the partial mapping M(s) and are the destination of the edges from graph G{\tiny B}
	
The pair (n,m) is made by vertex n from T{\tiny A}out(s) and m from T{\tiny B}out(s). If the any of the sets is empty, then we consider the vertex n from T{\tiny A}in(s) and m from T{\tiny B}in(s). In the case where that graphs are not connected, the pairs will be made by all the vertex not yet contained in either G{\tiny A}(s) and G{\tiny B}(s). These pairs form the entries in the set P(s) for that respective state s.

\subsubsection{The feasibility rules}
The feasibility rules that are used to ensure that the states that are evaluated play a role in improving the performance, by preventing inconsistent states from being explored and thus optimizing the execution of the algorithm. There are five general feasibility rules defined as R{\tiny pred},R{\tiny succ},R{\tiny in},R{\tiny out} and R{\tiny new} respectively A more formal definition is as follows:
	\begin{equation}
		Fsyn(s,n,m) = Rpred \wedge Rsucc \wedge Rin \wedge Rout \wedge Rnew 
	\end{equation} 
 A more formal definition of each rule is provided below.

The feasibility functions check for two main things, firstly they check the consistency of the partial solution in the successor state s', namely M(s'). Rules R{\tiny pred} and R{\tiny succ} are the rules used for this checking.
The remaining rules are used for pruning the search space for different levels of look ahead. The R{\tiny in} and R{\tiny out} are used to look ahead one level and determine which of those successor states are consistent, and R{\tiny new} is used for the same purpose, but for a look ahead level of two. This brings us to the conclusion that, in order for a state to be considered consistent it must pass a combination of all of the five rules, namely:


\subimport{}{rules}


This, as described earlier is defined as the feasibility function.